{
  "name": "level-ttl",
  "description": "Adds a 'ttl' option to LevelUP for puts and batches",
  "contributors": [
    {
      "name": "Rod Vagg",
      "email": "r@va.gg",
      "url": "https://github.com/rvagg"
    },
    {
      "name": "Matteo Collina",
      "email": "matteo.collina@gmail.com",
      "url": "https://github.com/mcollina"
    },
    {
      "name": "Josh Duff",
      "email": "me@JoshDuff.com",
      "url": "https://github.com/TehShrike"
    }
  ],
  "version": "0.5.0",
  "homepage": "https://github.com/rvagg/node-level-ttl",
  "authors": [
    "Rod Vagg <rod@vagg.org> (https://github.com/rvagg)"
  ],
  "keywords": [
    "leveldb",
    "levelup",
    "ttl",
    "whoa dude!"
  ],
  "main": "./level-ttl.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/rvagg/node-level-ttl.git"
  },
  "dependencies": {
    "after": "~0.8.1",
    "xtend": "~2.1.1"
  },
  "peerDependencies": {},
  "devDependencies": {
    "tape": "*",
    "level": "*",
    "rimraf": "*",
    "level-sublevel": "*"
  },
  "scripts": {
    "test": "node ./test.js"
  },
  "license": "MIT",
  "readme": "# Level TTL [![Build Status](https://secure.travis-ci.org/rvagg/node-level-ttl.png)](http://travis-ci.org/rvagg/node-level-ttl)\n\n![LevelDB Logo](https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png)\n\n[![NPM](https://nodei.co/npm/level-ttl.png?downloads)](https://nodei.co/npm/level-ttl/)\n\n**Add a `'ttl'` (time-to-live) option to LevelUP for `put()` and `batch()`**\n\nAugment LevelUP to handle a new `'ttl'` option on `put()` and `batch()` that specifies the number of milliseconds an entry should remain in the data store. After the TTL, the entry will be automatically cleared for you.\n\nRequires [LevelUP](https://github.com/rvagg/node-levelup) (or [Level](https://github.com/level/level)) and [sublevel](https://github.com/dominictarr/level-sublevel) to be installed separately.\n\n```js\nvar levelup  = require('level')\n  , ttl      = require('level-ttl')\n  , sublevel = require('level-sublevel')\n\nlevelup('/tmp/foo.db', function (err, db) {\n  db = sublevel(db)\n  db = ttl(db)\n\n  // --------------------------- put() --------------------------- //\n  // this entry will only stay in the data store for 1 hour\n  db.put('foo', 'bar', { ttl: 1000 * 60 * 60 }, function (err) { /* .. */ })\n\n  // -------------------------- batch() -------------------------- //\n  // the two 'put' entries will only stay in the data store for 1 hour\n  db.batch([\n      { type: 'put', key: 'foo', value: 'bar' }\n    , { type: 'put', key: 'bam', value: 'boom' }\n    , { type: 'del', key: 'w00t' }\n  ], { ttl: 1000 * 60 * 60 }, function (err) { /* .. */ })\n})\n```\n\nIf you put the same entry twice, you **refresh** the TTL to the *last* put operation. In this way you can build utilities like [session managers](https://github.com/rvagg/node-level-session/) for your web application where the user's session is refreshed with each visit but expires after a set period of time since their last visit.\n\nAlternatively, for a lower write-footprint you can use the `ttl()` method that is added to your LevelUP instance which can serve to insert or update a ttl for any given key in the database (even if that key doesn't exist but may in the future! Crazy!).\n\n```js\ndb.put('foo', 'bar', function (err) { /* .. */ })\ndb.ttl('foo', 1000 * 60 * 60, function (err) { /* .. */ })\n```\n\n**Level TTL** uses an internal scan every 10 seconds by default, this limits the available resolution of your TTL values, possibly delaying a delete for up to 10 seconds. The resolution can be tuned by passing the `'checkFrequency'` option to the `ttl()` initialiser.\n\n```js\nlevelup('/tmp/foo.db', function (err, db) {\n  // scan for deletables every second\n  db = ttl(db, { checkFrequency: 1000 })\n\n  /* .. */\n})\n```\n\nOf course, a scan takes some resources, particularly on a data store that makes heavy use of TTLs. If you don't require high accuracy for actual deletions then you can increase the `'checkFrequency'`. Note though that a scan only involves invoking a LevelUP ReadStream that returns *only the entries due to expire*, so it doesn't have to manually check through all entries with a TTL. As usual, it's best to not do too much tuning until you have you have something worth tuning!\n\n### Shutting down\n\n**Level TTL** uses a timer to regularly check for expiring entries (don't worry, the whole data store isn't scanned, it's very efficient!) but this can cause problems for processes that have a limited lifespan; particularly when testing. The `db.close()` method is automatically wired to stop the timer but there is also a more explicit <b><code>db.stop()</code></b> method that will stop the timer and not pass on to a `close()` underlying LevelUP instance.\n\n## Contributors\n\n**Level TTL** is powered by the following hackers:\n\n * [Rod Vagg](https://github.com/rvagg)\n * [Matteo Collina](https://github.com/mcollina)\n * [Josh Duff](https://github.com/TehShrike)\n\n## Licence\n\nLevel TTL is Copyright (c) 2013 Rod Vagg [@rvagg](https://twitter.com/rvagg) and licensed under the MIT licence. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rvagg/node-level-ttl/issues"
  },
  "_id": "level-ttl@0.5.0",
  "_shasum": "5d6d242e48880484fed3e6cf4d2ddd3e59a1301c",
  "_from": "level-ttl@~0.5.0",
  "_resolved": "https://registry.npmjs.org/level-ttl/-/level-ttl-0.5.0.tgz"
}
