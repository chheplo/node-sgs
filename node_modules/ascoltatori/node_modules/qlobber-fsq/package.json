{
  "name": "qlobber-fsq",
  "description": "Shared file system queue. Supports pub-sub, work queues, wildcards, multi-process and distributed use.",
  "version": "0.0.5",
  "homepage": "https://github.com/davedoesdev/qlobber-fsq",
  "author": {
    "name": "David Halls",
    "email": "dave@davedoesdev.com",
    "url": "http://www.davedoesdev.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/davedoesdev/qlobber-fsq.git"
  },
  "bugs": {
    "url": "https://github.com/davedoesdev/qlobber-fsq/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/davedoesdev/qlobber-fsq/blob/master/LICENCE"
    }
  ],
  "main": "index.js",
  "scripts": {
    "test": "grunt lint test",
    "travis-test": "grunt lint test coverage coveralls",
    "travis-test-stress": "grunt test-stress",
    "travis-test-multi": "grunt test-multi",
    "travis-test-multi-remote": "grunt test-multi --remote localhost"
  },
  "directories": {
    "test": "test",
    "lib": "lib"
  },
  "keywords": [
    "amqp",
    "mqtt",
    "rabbitmq",
    "cybertron",
    "ascoltatore",
    "qlobber",
    "pubsub",
    "queue",
    "routing"
  ],
  "dependencies": {
    "qlobber": "~0.3.8",
    "async": "~0.2.9",
    "fs-ext": "~0.3.2",
    "buffertools": "~2.0.0",
    "graceful-fs": "~2.0.1"
  },
  "devDependencies": {
    "grunt": "~0.4.2",
    "grunt-cli": "~0.1.13",
    "grunt-jslint": "~1.1.5",
    "grunt-cafe-mocha": "~0.1.11",
    "grunt-apidox": "~0.1.4",
    "chai": "~1.9.0",
    "istanbul": "~0.2.6",
    "grunt-exec": "~0.4.5",
    "coveralls": "~2.8.0",
    "b": "git://github.com/davedoesdev/b.git",
    "rimraf": "~2.2.6",
    "lsof": "~0.0.3",
    "yargs": "~1.2.1",
    "cp-remote": "~0.0.3"
  },
  "readme": "# qlobber-fsq&nbsp;&nbsp;&nbsp;[![Build Status](https://travis-ci.org/davedoesdev/qlobber-fsq.png)](https://travis-ci.org/davedoesdev/qlobber-fsq) [![Coverage Status](https://coveralls.io/repos/davedoesdev/qlobber-fsq/badge.png?branch=master)](https://coveralls.io/r/davedoesdev/qlobber-fsq?branch=master) [![NPM version](https://badge.fury.io/js/qlobber-fsq.png)](http://badge.fury.io/js/qlobber-fsq)\n\nShared file system queue for Node.js.\n\n- Supports pub-sub and work queues.\n- Supports local file system for multi-core use.\n- Tested with [FraunhoferFS](http://www.fhgfs.com/) for distributed use ([CephFS](http://ceph.com/ceph-storage/file-system/) testing in progress).\n- Highly configurable.\n- Full set of unit tests, including stress tests.\n- Use as a backend-less alternative to [RabbitMQ](http://www.rabbitmq.com/), [Redis pub-sub](http://redis.io/topics/pubsub) etc.\n- Supports AMQP-like topics with single- and multi-level wildcards.\n\nExample:\n\n```javascript\nvar QlobberFSQ = require('qlobber-fsq').QlobberFSQ;\nvar fsq = new QlobberFSQ({ fsq_dir: '/shared/fsq' });\nfsq.subscribe('foo.*', function (data, info)\n{\n    console.log(info.topic, data.toString('utf8'));\n    var assert = require('assert');\n    assert.equal(info.topic, 'foo.bar');\n    assert.equal(data, 'hello');\n});\nfsq.on('start', function ()\n{\n    this.publish('foo.bar', 'hello');\n});\n```\n\nYou can publish messages using a separate process if you like:\n\n```javascript\nvar QlobberFSQ = require('qlobber-fsq').QlobberFSQ;\nvar fsq = new QlobberFSQ({ fsq_dir: '/shared/fsq' });\nfsq.stop_watching();\nfsq.on('stop', function ()\n{\n    this.publish('foo.bar', 'hello');\n});\n```\n\nOr use the streaming interface to read and write messages:\n\n```javascript\nvar QlobberFSQ = require('qlobber-fsq').QlobberFSQ;\nvar fsq = new QlobberFSQ({ fsq_dir: '/shared/fsq' });\nfsq.subscribe('foo.*', { stream: true }, function (stream, info)\n{\n    var data = [];\n\n    stream.on('data', function (chunk)\n    {\n        data.push(chunk);\n    });\n\n    stream.on('end', function ()\n    {\n        var str = Buffer.concat(data).toString('utf8');\n        console.log(info.topic, str);\n        var assert = require('assert');\n        assert.equal(info.topic, 'foo.bar');\n        assert.equal(str, 'hello');\n    });\n});\nfsq.on('start', function ()\n{\n    fsq.publish('foo.bar').end('hello');\n});\n```\n\nThe API is described [here](#tableofcontents).\n\n## Installation\n\n```shell\nnpm install qlobber-fsq\n```\n\n## Limitations\n\n- `qlobber-fsq` provides no guarantee that the order messages are given to subscribers is the same as the order in which the messages were written. If you want to maintain message order between readers and writers then you'll need to do it in your application (using ACKs, sliding windows etc).\n\n- `qlobber-fsq` does its best not to lose messages but in exceptional circumstances (e.g. process crash, file system corruption) messages may get dropped. You should design your application to be resilient against dropped messages.\n\n- `qlobber-fsq` makes no assurances about the security or privacy of messages in transit or at rest. It's up to your application to encrypt messages if required.\n\n- `qlobber-fsq` supports Node 0.10 onwards.\n\n## FraunhoferFS\n\nWhen using the FraunhoferFS distributed file system, set the following options in `fhgfs-client.conf`:\n\n```\ntuneFileCacheType             = none\ntuneUseGlobalFileLocks        = true\n```\n\nWhen using a distributed file system with `qlobber-fsq`, ensure that your synchronize the time and date on all the computers you're using.\n\n## How it works\n\n![How it works](http://githubraw.herokuapp.com/davedoesdev/qlobber-fsq/master/diagrams/how_it_works.svg)\n\nUnder the directory you specify for `fsq_dir`, `qlobber-fsq` creates the following sub-directories:\n\n- `staging` Whilst it's being published, each message is written to a file in the staging area. The filename itself contains the message's topic, when it expires, whether it should be read by one subscriber or many and a random sequence of characters to make it unique.\n- `messages` Once published to the staging area, each message is moved into this directory. `qlobber-fsq` actually creates a number of sub-directories (called buckets) under `messages` and distributes message between buckets according to the hash of their filenames. This helps to reduce the number of directory entries that have to be read when a single message is written. \n- `topics` If a message's topic is long, a separate topic file is created for it in this directory.\n- `update` This contains one file, `UPDATE`, which is updated with a random sequence of bytes (called a stamp) every time a message is moved into the `messages` directory. `UPDATE` contains a separate stamp for each bucket.\n\n`qlobber-fsq` reads `UPDATE` at regular intervals to determine whether a new message has been written to a bucket. If it has then it processes each filename in the bucket's directory listing.\n\nIf the expiry time in the filename has passed then it deletes the message.\n\nIf the filename indicates the message can be read by many subscribers:\n\n- If it's processed this filename before then stop processing this filename.\n- If the topic in the filename matches any subscribers then call each subscriber with the file's content. It uses [`qlobber`](https://github.com/davedoesdev/qlobber) to pattern match topics to subscribers.\n- Remember that we've processed the filename.\n\nIf the filename indicates the message can be read by only one subscriber (i.e. work queue semantics):\n\n- Try to lock the file using `flock`. If it fails to lock the file then stop processing this filename.\n- If the topic in the filename matches any subscribers then call one subscriber with the file's content.\n- Truncate and delete the file before unlocking it. We truncate the file in case of directory caching.\n\n## Licence\n\n[MIT](LICENCE)\n\n## Test\n\nTo run the default tests:\n\n```shell\ngrunt test [--fsq-dir <path>]\n```\n\nIf you don't specify `--fsq-dir` then the default will be used (a directory named `fsq` in the `qlobber-fsq` module directory).\n\nTo run the stress tests (multiple queues in a single Node process):\n\n```shell\ngrunt test-stress [--fsq-dir <path>]\n```\n\nTo run the multi-process tests (each process publishing and subscribing to different messages):\n\n```shell\ngrunt test-multi [--fsq-dir <path>] [--queues <number of queues>]\n```\n\nIf you omit `--queues` then one process will be created per core (detected with [`os.cpus()`](http://nodejs.org/api/os.html#os_os_cpus)).\n\nTo run the distributed tests (one Node process per remote host, each one publishing and subscribing to different messages);\n\n```shell\ngrunt test-multi --fsq-dir <path> --remote <host1> --remote <host2>\n```\n\nYou can specify as many remote hosts as you like. The test uses [`cp-remote`](https://github.com/davedoesdev/cp-remote) to run a module on each remote host. Make sure on each host:\n\n- The `qlobber-fsq` module is installed at the same location.\n- Mount the same distributed file system on the directory you specify for `--fsq-dir`. FraunhoferFS is the only distributed file system currently supported.\n\n## Lint\n\n```shell\ngrunt lint\n```\n\n## Code Coverage\n\n```shell\ngrunt coverage\n```\n\n[Instanbul](http://gotwarlost.github.io/istanbul/) results are available [here](http://githubraw.herokuapp.com/davedoesdev/qlobber-fsq/master/coverage/lcov-report/index.html).\n\nCoveralls page is [here](https://coveralls.io/r/davedoesdev/qlobber-fsq).\n\n## Benchmarks\n\nTo run the benchmark:\n\n```shell\ngrunt bench [--fsq-dir <path>] \\\n            --rounds <number of rounds> \\\n            --size <message size> \\\n            --ttl <message time-to-live in seconds> \\\n            (--queues <number of queues> | \\\n             --remote <host1> --remote <host2> ...)\n```\n\nIf you don't specify `--fsq-dir` then the default will be used (a directory named `fsq` in the `qlobber-fsq` module directory).\n\nIf you provide at least one `--remote <host>` argument then the benchmark will be distributed across multiple hosts using [`cp-remote`](https://github.com/davedoesdev/cp-remote). Make sure on each host:\n\n- The `qlobber-fsq` module is installed at the same location.\n- Mount the same distributed file system on the directory you specify for `--fsq-dir`. FraunhoferFS is the only distributed file system currently supported.\n\n# API\n\n<a name=\"tableofcontents\"></a>\n\n\n## Constructor\n- <a name=\"toc_qlobberfsqoptions\"></a>[QlobberFSQ](#qlobberfsqoptions)\n\n## Publish and subscribe\n- <a name=\"toc_qlobberfsqprototypesubscribetopic-options-handler-cb\"></a><a name=\"toc_qlobberfsqprototype\"></a>[QlobberFSQ.prototype.subscribe](#qlobberfsqprototypesubscribetopic-options-handler-cb)\n- <a name=\"toc_qlobberfsqprototypeunsubscribetopic-handler-cb\"></a>[QlobberFSQ.prototype.unsubscribe](#qlobberfsqprototypeunsubscribetopic-handler-cb)\n- <a name=\"toc_qlobberfsqprototypepublishtopic-payload-options-cb\"></a>[QlobberFSQ.prototype.publish](#qlobberfsqprototypepublishtopic-payload-options-cb)\n\n## Lifecycle\n- <a name=\"toc_qlobberfsqprototypestop_watchingcb\"></a>[QlobberFSQ.prototype.stop_watching](#qlobberfsqprototypestop_watchingcb)\n- <a name=\"toc_qlobberfsqprototypeis_watching\"></a>[QlobberFSQ.prototype.is_watching](#qlobberfsqprototypeis_watching)\n- <a name=\"toc_qlobberfsqprototyperefresh_now\"></a>[QlobberFSQ.prototype.refresh_now](#qlobberfsqprototyperefresh_now)\n- <a name=\"toc_qlobberfsqprototypeforce_refresh\"></a>[QlobberFSQ.prototype.force_refresh](#qlobberfsqprototypeforce_refresh)\n\n## Events\n- <a name=\"toc_qlobberfsqeventsstart\"></a><a name=\"toc_qlobberfsqevents\"></a>[QlobberFSQ.events.start](#qlobberfsqeventsstart)\n- <a name=\"toc_qlobberfsqeventsstop\"></a>[QlobberFSQ.events.stop](#qlobberfsqeventsstop)\n- <a name=\"toc_qlobberfsqeventserrorerr\"></a>[QlobberFSQ.events.error](#qlobberfsqeventserrorerr)\n- <a name=\"toc_qlobberfsqeventswarningerr\"></a>[QlobberFSQ.events.warning](#qlobberfsqeventswarningerr)\n\n## QlobberFSQ([options])\n\n> Creates a new `QlobberFSQ` object for publishing and subscribing to a file system queue.\n\n**Parameters:**\n\n- `{Object} [options]` Configures the file system queue. Valid properties are listed below:\n\n\n  - `{String} [fsq_dir]` The path to the file system queue directory. Note that the following sub-directories will be created under this directory if they don't exist: `messages`, `staging`, `topics` and `update`. Defaults to a directory named `fsq` in the `qlobber-fsq` module directory.\n\n  - `{Integer} split_topic_at` Maximum number of characters in a short topic. Short topics are contained entirely in a message's filename. Long topics are split so the first `split_topic_at` characters go in the filename and the rest are written to a separate file in the `topics` sub-directory. Obviously long topics are less efficient. Defaults to 200, which is the maximum for most common file systems. Note: if your `fsq_dir` is on an [`ecryptfs`](http://ecryptfs.org/) file system then you should set `split_topic_at` to 100.\n\n  - `{Integer} bucket_base`, `{Integer} bucket_num_chars` Messages are distributed across different _buckets_ for efficiency. Each bucket is a sub-directory of the `messages` directory. The number of buckets is determined by the `bucket_base` and `bucket_num_chars` options. `bucket_base` is the radix to use for bucket names and `bucket_num_chars` is the number of digits in each name. For example, `bucket_base: 26` and `bucket_num_chars: 4` results in buckets `00` through `pppp`. Defaults to `base_base: 16` and `bucket_num_chars: 2` (i.e. buckets `00` through `ff`).\n\n  - `{Integer} bucket_stamp_size` The number of bytes to write to the `UPDATE` file when a message is published. The `UPDATE` file (in the `update` directory) is used to determine whether any messages have been published without having to scan all the bucket directories. Each bucket has a section in the `UPDATE` file, `bucket_stamp_size` bytes long. When a message is written to a bucket, its section is filled with random bytes. Defaults to 32.\n\n  - `{Integer} flags` Extra flags to use when reading and writing files. You shouldn't need to use this option but if you do then it should be a bitwise-or of values in the (undocumented) Node `constants` module (e.g. `constants.O_DIRECT | constants.O_SYNC`). Defaults to 0.\n\n  - `{Integer} unique_bytes` Number of random bytes to append to each message's filename (encoded in hex), in order to avoid name clashes. Defaults to 16. If you increase it (or change the algorithm to add some extra information like the hostname), be sure to reduce `split_topic_at` accordingly.\n\n  - `{Integer} single_ttl` Default time-to-live (in milliseconds) for messages which should be read by at most one subscriber. This value is added to the current time and the resulting expiry time is put into the message's filename. After the expiry time, the message is ignored and deleted when convenient. Defaults to 1 hour. \n\n  - `{Integer} multi_ttl` Default time-to-live (in milliseconds) for messages which can be read by many subscribers. This value is added to the current time and the resulting expiry time is put into the message's filename. After the expiry time, the message is ignored and deleted when convenient. Defaults to 5 seconds.\n\n  - `{Integer} poll_interval` `qlobber-fsq` reads the `UPDATE` file at regular intervals to check whether any messages have been written. `poll_interval` is the time (in milliseconds) between each check. Defaults to 1 second.\n\n  - `{Boolean} notify` Whether to use [`fs.watch`](http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener) to watch for changes to the `UPDATE` file. Note that this will be done in addition to reading it every `poll_interval` milliseconds because `fs.watch` (`inotify` underneath) can be unreliable, especially under high load.\n\n  - `{Integer} retry_interval` Some I/O operations can fail with an error indicating they should be retried. `retry_interval` is the time (in milliseconds) to wait before retrying.\n\n  - `{Integer} message_concurrency` The number of messages is each bucket to process at once. Defaults to 1.\n\n  - `{Integer} bucket_concurrency` The number of buckets to process at once. Defaults to 1.\n\n  - `{Boolean} dedup` Whether to ensure each handler function is called at most once when a message is received. Defaults to `true`.\n\n  - `{String} separator` The character to use for separating words in message topics. Defaults to `.`.\n\n  - `{String} wildcard_one` The character to use for matching exactly one word in a message topic to a subscriber. Defaults to `*`.\n\n  - `{String} wildcard_some` The character to use for matching zero or more words in a message topic to a subscriber. Defaults to `#`.\n\n<sub>Go: [TOC](#tableofcontents)</sub>\n\n<a name=\"qlobberfsqprototype\"></a>\n\n## QlobberFSQ.prototype.subscribe(topic, [options], handler, cb)\n\n> Subscribe to messages in the file system queue.\n\n**Parameters:**\n\n- `{String} topic` Which messages you're interested in receiving. Message topics are split into words using `.` as the separator. You can use `*` to match exactly one word in a topic or `#` to match zero or more words. For example, `foo.*` would match `foo.bar` whereas `foo.#` would match `foo`, `foo.bar` and `foo.bar.wup`. Note you can change the separator and wildcard characters by specifying the `separator`, `wildcard_one` and `wildcard_some` options when [constructing `QlobberFSQ` objects](#qlobberfsqoptions). See the [`qlobber` documentation](https://github.com/davedoesdev/qlobber#qlobberoptions) for more information.\n\n\n\n- `{Object} [options]` Optional settings for this subscription:\n\n\n  - `{Boolean} stream` Whether `handler` should receive a message stream or the message contents as its first argument. Defaults to `false` (the message contents).\n\n\n- `{Function} handler` Function to call when a new message is received on the file system queue and its topic matches against `topic`. `handler` will be passed the following arguments:\n\n\n  - `{Buffer|Stream} data` Message stream or message contents, depending on `options.stream`.\n\n  - `{Object} info` Metadata for the message, with the following properties:\n\n    - `{String} fname` Name of the file in which the message is stored.\n    - `{String} path` Full path to the file in which the message is stored.\n    - `{String} topic` Topic the message was published with.\n    - `{String} [topic_path]` Full path to the file in which the topic overspill is stored (only present if the topic is too long to fit in the file name).\n    - `{Integer} expires` When the message expires (number of milliseconds after 1 January 1970 00:00:00 UTC).\n    - `{Boolean} single` Whether this message is being given to at most one subscriber (across all `QlobberFSQ` objects).\n\n  - `{Function} done` Function to call once you've handled the message. Note that calling this function is only mandatory if `info.single === true`, in order to delete and unlock the file. `done` takes two arguments:\n\n    - `{Object} err` If an error occurred then pass details of the error, otherwise pass `null` or `undefined`.\n    - `{Function} [finish]` Optional function to call once the message has been deleted and unlocked, in the case of `info.single === true`, or straight away otherwise. It will be passed the following argument:\n    - `{Object} err` If an error occurred then details of the error, otherwise `null`.\n\n\n- `{Function} cb` Function to call once the subscription has been registered. This will be passed the following argument:\n\n\n    - `{Object} err` If an error occurred then details of the error, otherwise `null`.\n\n**Notes on handlers:**\n\nYou can set two optional properties on the `handler` function, to control when messages are delivered to subscribers:\n\n  - `{Function} accept`. A function which should take message metadata (see `info` above) and return whether `handler` wants to receive this particular message. If a `handler` has no `accept` function then it's assumed to want to receive the message.\n\n  - `{Function} ready`. A function which should take message metadata (see `info` above) and return whether `handler` is ready to receive the message _at this time_. A message being given to more than one subscriber (`info.single === false`) won't be read into memory or given to _any_ `handler` until the `ready` functions for _all_ handlers return `true`. If a `handler` has no `ready` function then it's assumed to be ready to receive the message.\n\nWhile using `ready` functions allows `qlobber-fsq` to help you handle back-pressure in your application, it does limit message throughput to that of the slowest subscriber. You are of course free not to use `ready` functions on your subscribers and handle back-pressure yourself.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n## QlobberFSQ.prototype.unsubscribe([topic], [handler], cb)\n\n> Unsubscribe from messages in the file system queue.\n\n**Parameters:**\n\n- `{String} [topic]` Which messages you're no longer interested in receiving via the `handler` function. This should be a topic you've previously passed to [`subscribe`](#qlobberfsqprototypesubscribetopic-options-handler-cb). If topic is `undefined` then all handlers for all topics are unsubscribed.\n\n\n\n- `{Function} [handler]` The function you no longer want to be called with messages published to the topic `topic`. This should be a function you've previously passed to [`subscribe`](#qlobberfsqprototypesubscribetopic-options-handler-cb). If you subscribed `handler` to a different topic then it will still be called for messages which match that topic. If `handler` is undefined, all handlers for the topic `topic` are unsubscribed.\n\n\n\n- `{Function} cb` Function to call once `handler` has been unsubscribed from `topic`. This will be passed the following argument:\n\n\n    - `{Object} err` If an error occurred then details of the error, otherwise `null`.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n## QlobberFSQ.prototype.publish(topic, [payload], [options], [cb])\n\n> Publish a message to the file system queue.\n\n**Parameters:**\n\n- `{String} topic` Message topic. The topic should be a series of words separated by `.` (or the `separator` character you provided to the [`QlobberFSQ constructor`](#qlobberfsqoptions)). Since the unencoded topic string is used as part of the message's filename, topic words can contain any valid file name character for your file system. However, it's probably sensible to limit it to alphanumeric characters, `-`, `_` and `.`.\n\n\n\n- `{String | Buffer} [payload]` Message payload. If you don't pass a payload then `publish` will return a [Writable stream](http://nodejs.org/api/stream.html#stream_class_stream_writable) for you to write the payload into.\n\n\n\n- `{Object} [options]` Optional settings for this publication:\n\n\n  - `{Boolean} single` If `true` then the message will be given to _at most_ one interested subscriber, across all `QlobberFSQ` objects scanning the file system queue. Otherwise all interested subscribers will receive the message.\n\n  - `{Integer} ttl` Time-to-live (in milliseconds) for this message. If you don't specify anything then `single_ttl` or `multi_ttl` (provided to the [`QlobberFSQ constructor`](#qlobberfsqoptions)) will be used, depending on the value of `single`. After the time-to-live for the message has passed, the message is ignored and deleted when convenient.\n\n  - `{String} encoding` If `payload` is a string, the encoding to use when writing it out to the message file. Defaults to `utf8`.\n\n  - `{Integer} mode` The file mode (permissions) to set on the message file. Defaults to octal `0666` (readable and writable to everyone).\n\n  - `{Function} hasher` A hash function to use for deciding into which bucket the message should be placed. The hash function should return a `Buffer` at least 4 bytes long. It defaults to running `md5` on the message file name. If you supply a `hasher` function it will be passed the following arguments:\n\n    - `{String} fname` Message file name.\n    - `{Integer} expires` When the message expires (number of milliseconds after 1 January 1970 00:00:00 UTC).\n    - `{String} topic` Message topic.\n    - `{String|Buffer} payload` Message payload.\n    - `{Object} options` The optional settings for this publication.\n\n\n- `{Function} [cb]` Optional function to call once the message has been written to the file system queue. This will be called after the message has been moved into its bucket and is therefore available to subscribers in any `QlobberFSQ` object scanning the queue. It will be passed the following argument:\n\n\n  - `{Object} err` If an error occurred then details of the error, otherwise `null`.\n\n\n**Return:**\n\n`{Stream | undefined}` A [Writable stream](http://nodejs.org/api/stream.html#stream_class_stream_writable) if no `payload` was passed, otherwise `undefined`.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n## QlobberFSQ.prototype.stop_watching([cb])\n\n> Stop scanning for new messages.\n\n**Parameters:**\n\n- `{Function]} [cb]` Optional function to call once scanning has stopped. Alternatively, you can listen for the [`stop` event](#qlobberfsqeventsstop).\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n## QlobberFSQ.prototype.is_watching()\n\n> Return whether this `QlobberFSQ` object is scanning for messages.\n\n**Return:**\n\n`{Boolean}` Whether new messages will be detected.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n## QlobberFSQ.prototype.refresh_now()\n\n> Check the `UPDATE` file now rather than waiting for the next periodic check to occur\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n## QlobberFSQ.prototype.force_refresh()\n\n> Scan for new messages in the `messages` sub-directory without checking whether the `UPDATE` file has changed.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.prototype](#toc_qlobberfsqprototype)</sub>\n\n<a name=\"qlobberfsqevents\"></a>\n\n## QlobberFSQ.events.start()\n\n> `start` event\n\n`QlobberFSQ` objects fire a `start` event when they're ready to publish messages. Don't call [`publish`](#qlobberfsqprototypepublishtopic-payload-options-cb) until the `start` event is emitted or the message may be dropped. You can [`subscribe`](#qlobberfsqprototypesubscribetopic-options-handler-cb) to messages before `start` is fired, however.\n\nA `start` event won't be fired after a [`stop`](#qlobberfsqeventsstop) event.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.events](#toc_qlobberfsqevents)</sub>\n\n## QlobberFSQ.events.stop()\n\n> `stop` event\n\n`QlobberFSQ` objects fire a `stop` event after you call [`stop_watching`](#qlobberfsqprototypestop_watchingcb) and they've stopped scanning for new messages. Messages already read may still be being processed, however.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.events](#toc_qlobberfsqevents)</sub>\n\n## QlobberFSQ.events.error(err)\n\n> `error` event\n\n`QlobberFSQ` objects fire an `error` event if an error occurs before [`start`](#qlobberfsqeventsstart) is emitted. The `QlobberFSQ` object is unable to continue at this point and is not scanning for new messages.\n\n**Parameters:**\n\n- `{Object} err` The error that occurred.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.events](#toc_qlobberfsqevents)</sub>\n\n## QlobberFSQ.events.warning(err)\n\n> `warning` event\n\n`QlobberFSQ` objects fire a `warning` event if an error occurs after [`start`](#qlobberfsqeventsstart) is emitted. The `QlobberFSQ` object will still be scanning for new messages after emitting a `warning` event.\n\n**Parameters:**\n\n- `{Object} err` The error that occurred.\n\n<sub>Go: [TOC](#tableofcontents) | [QlobberFSQ.events](#toc_qlobberfsqevents)</sub>\n\n_&mdash;generated by [apidox](https://github.com/codeactual/apidox)&mdash;_\n",
  "readmeFilename": "README.md",
  "_id": "qlobber-fsq@0.0.5",
  "_shasum": "b9a03b104993839a40e03141753a2540baa74246",
  "_from": "qlobber-fsq@~0.0.3",
  "_resolved": "https://registry.npmjs.org/qlobber-fsq/-/qlobber-fsq-0.0.5.tgz"
}
